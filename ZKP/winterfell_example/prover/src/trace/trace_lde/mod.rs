// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

use super::{ColMatrix, EvaluationFrame, FieldElement, StarkField, TracePolyTable};
use crate::StarkDomain;
use air::{proof::Queries, TraceInfo, TraceLayout};
use crypto::{ElementHasher, Hasher};
use utils::collections::Vec;

mod default;
pub use default::DefaultTraceLde;

// TRACE LOW DEGREE EXTENSION
// ================================================================================================
/// Contains all segments of the extended execution trace and their commitments.
///
/// Segments are stored in two groups:
/// - Main segment: this is the first trace segment generated by the prover. Values in this segment
///   will always be elements in the base field (even when an extension field is used).
/// - Auxiliary segments: a list of 0 or more segments for traces generated after the prover
///   commits to the first trace segment. Currently, at most 1 auxiliary segment is possible.
pub trait TraceLde: Sync {
    /// The base field, used for computation on the main trace segment.
    type BaseField: StarkField;
    /// The extension field, used for computation on auxiliary trace segments.
    type ExtensionField: FieldElement<BaseField = Self::BaseField>;
    /// The hash function used for building the Merkle tree commitments to trace segment LDEs.
    type HashFn: ElementHasher<BaseField = Self::BaseField>;

    /// Takes the main trace segment columns as input, interpolates them into polynomials in
    /// coefficient form, and evaluates the polynomials over the LDE domain.
    ///
    /// Returns a tuple containing a [TracePolyTable] with the trace polynomials for the main trace
    /// and a new [TraceLde] instance from which the LDE and trace commitments can be obtained.
    fn new(
        trace_info: &TraceInfo,
        main_trace: &ColMatrix<Self::BaseField>,
        domain: &StarkDomain<Self::BaseField>,
    ) -> (TracePolyTable<Self::ExtensionField>, Self);

    /// Returns the commitment to the low-degree extension of the main trace segment.
    fn get_main_trace_commitment(&self) -> <Self::HashFn as Hasher>::Digest;

    /// Takes auxiliary trace segment columns as input, interpolates them into polynomials in
    /// coefficient form, evaluates the polynomials over the LDE domain, and commits to the
    /// polynomial evaluations.
    ///
    /// Returns a tuple containing the column polynomials in coefficient form and the commitment
    /// to the polynomial evaluations over the LDE domain.
    ///
    /// # Panics
    ///
    /// This function is expected to panic if any of the following are true:
    /// - the number of rows in the provided `aux_trace` does not match the main trace.
    /// - this segment would exceed the number of segments specified by the trace layout.
    fn add_aux_segment(
        &mut self,
        aux_trace: &ColMatrix<Self::ExtensionField>,
        domain: &StarkDomain<Self::BaseField>,
    ) -> (
        ColMatrix<Self::ExtensionField>,
        <Self::HashFn as Hasher>::Digest,
    );

    /// Reads current and next rows from the main trace segment into the specified frame.
    fn read_main_trace_frame_into(
        &self,
        lde_step: usize,
        frame: &mut EvaluationFrame<Self::BaseField>,
    );

    /// Reads current and next rows from the auxiliary trace segment into the specified frame.
    fn read_aux_trace_frame_into(
        &self,
        lde_step: usize,
        frame: &mut EvaluationFrame<Self::ExtensionField>,
    );

    /// Returns trace table rows at the specified positions along with Merkle authentication paths
    /// from the commitment root to these rows.
    fn query(&self, positions: &[usize]) -> Vec<Queries>;

    /// Returns the number of rows in the execution trace.
    fn trace_len(&self) -> usize;

    /// Returns blowup factor which was used to extend original execution trace into trace LDE.
    fn blowup(&self) -> usize;

    /// Returns the trace layout of the execution trace.
    fn trace_layout(&self) -> &TraceLayout;
}
